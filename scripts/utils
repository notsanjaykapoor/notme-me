#!/usr/bin/env python

import subprocess
import time

import click
import dotenv
import requests
import ulid

dotenv.load_dotenv()

DEFAULT_APP_CHECK_INTERVAL = 2
DEFAULT_APP_CHECK_TIMEOUT = 20

DEFAULT_SSH_CHECK_INTERVAL = 3
DEFAULT_SSH_CHECK_TIMEOUT = 15

DOCKER_APPS = ["notme-prd"]

GCP_REPO = "us-docker.pkg.dev/notme-330419/notme/notme-me" # public
# GCP_REPO = "gcr.io/notme-330419/notme-me" # private repo


@click.group()
def cli():
    pass



@click.command()
@click.option("--dockerfile", default="Dockerfile", required=False, help="")
@click.option("--sha", default="", required=False, help="git repo sha or tag")
@click.option("--no-push", is_flag=True, show_default=True, default=True, help="")
def build(dockerfile: str, sha: str, no_push: bool):
    time_start_unix = time.time()

    version = sha or ulid.new()

    print("docker build '{dockerfile}' version {version}", end=" ... ", flush=True)

    _docker_build(dockerfile=dockerfile, version=version, push=no_push)

    _print_ok("ok")

    time_end_unix = time.time()
    time_mins = round((time_end_unix - time_start_unix) / 60, 1)

    _print_ok(f"build completed in {time_mins} mins")


@click.command()
@click.option("--host", default=None, required=True, help="host or ip address")
@click.option("--user", default=None, required=True, help="ssh username")
@click.option("--site", default="https://www.notme.one", required=False, help="site uri")
def deploy(host: str, user: str, site: str):
    time_start_unix = time.time()

    print(f"host {host} ping", end=" ... ", flush=True)

    timeout = 0
    while timeout < DEFAULT_SSH_CHECK_TIMEOUT:
        code = _host_check(host=host, user=user)
        if code == 0:
            break
        time.sleep(DEFAULT_SSH_CHECK_INTERVAL)
        timeout += DEFAULT_SSH_CHECK_INTERVAL

    _print_ok("ok")

    print(f"host {host} docker image pull", end=" ... ", flush=True)

    _docker_image_pull(host=host, user=user)

    _print_ok("ok")

    print(f"host {host} docker app stop", end=" ... ", flush=True)

    _docker_app_stop(host=host, user=user, apps=DOCKER_APPS)

    _print_ok("ok")

    print(f"host {host} docker network create/check", end=" ... ", flush=True)

    code = _docker_network_create(host=host, user=user)

    if code == 0:
        _print_ok("ok")
    elif code == 409:
        _print_ok("exists")

    print(f"host {host} docker app start", end=" ... ", flush=True)

    _docker_app_start(host=host, user=user)

    _print_ok("ok")


def _docker_app_stop(host: str, user: str, apps: list[str]) -> int:
    for app in apps:
        response = subprocess.run(
            f"ssh -t {user}@{host} 'docker stop {app}'",
            shell=True,
            capture_output=True,
        )

        if response.returncode not in [0, 1]: # 1 means container not running
            _print_error(response.stdout.decode("utf-8"))
            exit(response.returncode)

    return 0


def _docker_app_start(host: str, user: str) -> int:
    # app server
    response = subprocess.run(
        f"ssh -t {user}@{host} 'docker run --name notme-prd --network notme -d --rm -p 5000:5000 {GCP_REPO}:latest /app/bin/app-server --port 5000'",
        shell=True,
        capture_output=True,
    )

    if response.returncode != 0:
        _print_error(response.stdout.decode("utf-8"))
        exit(response.returncode)

    return response.returncode


def _docker_build(dockerfile: str, version: str, push: bool) -> int:
    response = subprocess.run(
        f"docker build -t {GCP_REPO}:{version} -t {GCP_REPO}:latest --platform linux/amd64 --build-arg APP_VERSION={version} -f {dockerfile} .",
        shell=True,
        capture_output=False,
    )

    if response.returncode != 0:
        exit(response.returncode)

    if push:
        response = subprocess.run(
            f"docker push {GCP_REPO}:{version}",
            shell=True,
            capture_output=False,
        )

        if response.returncode != 0:
            exit(response.returncode)

        response = subprocess.run(
            f"docker push {GCP_REPO}:latest",
            shell=True,
            capture_output=False,
        )

        if response.returncode != 0:
            exit(response.returncode)

    return response.returncode


def _docker_image_pull(host: str, user: str) -> int:
    response = subprocess.run(
        f"ssh -t {user}@{host} 'docker image pull {GCP_REPO}:latest'",
        shell=True,
        capture_output=True,
    )

    if response.returncode not in [0]:
        _print_error(response.stdout.decode("utf-8"))
        exit(response.returncode)

    return response.returncode


def _docker_network_create(host: str, user: str) -> int:
    # create network
    response = subprocess.run(
        f"ssh -t {user}@{host} 'docker network create --driver bridge notme'",
        shell=True,
        capture_output=True,
    )

    if response.returncode != 0:
        error_message = response.stdout.decode("utf-8")

        if "already exists" in error_message:
            return 409
        else:
            _print_error(response.stdout.decode("utf-8"))
            exit(response.returncode)

    return response.returncode


def _host_check(host: str, user: str) -> int:
    ssh_code = subprocess.run(
        f"ssh -t {user}@{host} 'ls'",
        shell=True,
        capture_output=True,
    ).returncode

    if ssh_code not in [0]:
        exit(ssh_code)

    return ssh_code


def _print_error(s: str):
    print("\x1b[1;31m" + s + "\x1b[0m", flush=True)


def _print_ok(s: str):
    print("\x1b[1;32m" + s + "\x1b[0m", flush=True)


def _print_status(s: str):
    print("\x1b[1;36m" + s + "\x1b[0m", flush=True)


cli.add_command(build)
cli.add_command(deploy)

if __name__ == "__main__":
    cli()